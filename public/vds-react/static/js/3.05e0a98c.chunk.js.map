{"version":3,"sources":["../node_modules/@babel/runtime/helpers/toConsumableArray.js","../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/iterableToArray.js","../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../node_modules/shortid/lib/alphabet.js","../node_modules/shortid/index.js","../node_modules/shortid/lib/index.js","../node_modules/shortid/lib/random/random-from-seed.js","../node_modules/shortid/lib/build.js","../node_modules/shortid/lib/generate.js","../node_modules/shortid/lib/random/random-byte-browser.js","../node_modules/nanoid/format.js","../node_modules/shortid/lib/is-valid.js","../node_modules/shortid/lib/util/cluster-worker-id-browser.js","../node_modules/@visa/ui-utils/lib/js/card-number/constants/index.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/brandBinMatrix.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/acceptedBrandsCheck.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/getRawValue.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/possibleBrand.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/binCheck.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/filterAcceptedBrands.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/getBrandClassName.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/modCheck.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/getCardInfo.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/getMask.js","../node_modules/@visa/ui-utils/lib/js/card-number/utilities/validator.js","../node_modules/@visa/ui-utils/lib/js/card-number/index.js","../node_modules/@visa/ui-utils/lib/js/text-mask/conformToMask.js","../node_modules/@visa/ui-utils/lib/js/text-mask/adjustCaretPosition.js","../node_modules/@visa/ui-utils/lib/js/text-mask/createTextMaskInputElement.js","../node_modules/@visa/ui-utils/lib/js/text-mask/utilities.js","../node_modules/@visa/ui-utils/lib/js/text-mask/constants.js","../node_modules/@visa/ui-utils/lib/js/text-mask/index.js"],"names":["arrayWithoutHoles","iterableToArray","nonIterableSpread","module","exports","arr","Array","isArray","i","arr2","length","iter","Symbol","iterator","Object","prototype","toString","call","from","TypeError","alphabet","previousSeed","shuffled","randomFromSeed","ORIGINAL","reset","setCharacters","_alphabet_","Error","unique","split","filter","item","ind","lastIndexOf","join","getShuffled","characterIndex","sourceArray","targetArray","r","nextValue","Math","floor","push","splice","shuffle","get","characters","seed","lookup","index","build","isValid","clusterWorkerId","generate","seedValue","worker","workerId","newCharacters","undefined","_seed_","counter","previousSeconds","REDUCE_TIME","version","str","seconds","Date","now","random","format","number","done","loopCounter","pow","randomByte","crypto","window","msCrypto","getRandomValues","size","Uint8Array","bytes","mask","log","LN2","step","ceil","id","byte","RegExp","replace","test","COMPONENT_CLASSNAME","COMPONENT_WRAPPER_CLASSNAME","INDICATOR_CLASSNAME","INDICATOR_WRAPPER_CLASSNAME","LENGTH_AMEX","LENGTH_DEFAULT","FIVE_DIGITS","FOUR_DIGITS","SIX_DIGITS","AMEX_MASK","concat","NON_AMEX_MASK","AMEX","DISCOVER","ELECTRON","ELO","INVALID","MASTERCARD","UNKNOWN","VISA","EMPTY","INVALID_BIN","INVALID_BIN_BRAND","INVALID_GENERIC","NOT_SUPPORTED","PARTIAL","ERROR_MAP","empty","invalid_bin","invalid_bin_brand","invalid_generic","not_supported","partial","brandMatrix","binMatrix","fourDigits","ranges","4","max","min","5","6","7","8","twoOrThreeDigits","1","2","3","twoDigits","acceptedBrands","arguments","acceptedBrandsLength","isAccepted","cardBrand","brand","value","cardNum","eloBins","possibleBrand","firstDigit","indexOf","__checkTwoOrThreeDigits","digits","possibleBins","possibleBinsLength","isValidBin","bin","digitsToCheck","cardNumLengthOne","cardNumLength","substr","cardNumsToValidate","validationNumsLength","validationRange","Number","isFewerThanFourDigits","getRawValue","brandsLen","brands","unfilteredArr","v","a","brandIsKnown","prefix","brandName","toLowerCase","PRODUCT_ARRAY","mod11","checkMod11","isMod10","l","multiple","sum","parseInt","charAt","isMod11","temp","len","digit","testDigits","total","conditions","_conditions$cardBins","cardBins","_conditions$checkMods","checkMods","_conditions$partnerAc","partnerAcceptedBrands","_conditions$shouldChe","shouldCheckAcceptedBrands","_conditions$validateM","validateMod11","rawValue","maskedCardNumber","maxLength","passesMod","isSupportedBrand","acceptedBrandsCheck","binCheck","isSupported","isBlur","error","_conditions$checkMod","_conditions$isSupport","_conditions$isValid","isPartialValue","emptyArray","emptyString","conformToMask","config","_config$currentCaretP","currentCaretPosition","_config$guide","guide","_config$placeholder","placeholder","_config$placeholderCh","placeholderChars","_config$previousConfo","previousConformedValue","NO_MASK_ERROR","char","includes","NO_PLACEHOLDER_CHAR_IN_MASK","suppressGuide","rawValueLength","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","rawValueArr","conformedValue","someCharsRejected","placeholderLoop","_i","charInPlaceholder","rawValueChar","shift","indexOfLastFilledPlaceholderChar","_i2","meta","adjustCaretPosition","_ref","_ref$conformedValue","_ref$currentCaretPosi","_ref$nonRegexChars","nonRegexChars","_ref$placeholder","_ref$placeholderChars","_ref$previousConforme","_ref$previousPlacehol","previousPlaceholder","_ref$rawValue","conformedValueLength","editLength","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","intersection","previousLeftMaskChars","maskLengthChanged","targetIsMaskMovingLeft","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","lastPlaceholderChar","_i3","createTextMaskInputElement","state","update","_ref$guide","inputElement","_ref$placeholderChar","placeholderChar","_ref$upperCaseValue","upperCaseValue","isHTMLInputElement","NO_INPUT_ERROR","selectionEnd","inputValue","isNil","_cleanMask","cleanedMask","adjustedCaretPosition","_conformToMask","inputValueShouldBeEmpty","inputElementValue","toUpperCase","safeSetSelection","isAndroid","navigator","userAgent","defer","requestAnimationFrame","setTimeout","element","selectionPosition","document","activeElement","setSelectionRange","Element","HTMLDocument","nodeType","tagName","reduce","maskObj","maskChar","placeChar","cleanMask","Boolean","placeholderStr","Set"],"mappings":"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","file":"static/js/3.05e0a98c.chunk.js","sourcesContent":["var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\nvar shuffled;\n\nfunction reset() {\n  shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n  if (!_alphabet_) {\n    if (alphabet !== ORIGINAL) {\n      alphabet = ORIGINAL;\n      reset();\n    }\n\n    return;\n  }\n\n  if (_alphabet_ === alphabet) {\n    return;\n  }\n\n  if (_alphabet_.length !== ORIGINAL.length) {\n    throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n  }\n\n  var unique = _alphabet_.split('').filter(function (item, ind, arr) {\n    return ind !== arr.lastIndexOf(item);\n  });\n\n  if (unique.length) {\n    throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n  }\n\n  alphabet = _alphabet_;\n  reset();\n}\n\nfunction characters(_alphabet_) {\n  setCharacters(_alphabet_);\n  return alphabet;\n}\n\nfunction setSeed(seed) {\n  randomFromSeed.seed(seed);\n\n  if (previousSeed !== seed) {\n    reset();\n    previousSeed = seed;\n  }\n}\n\nfunction shuffle() {\n  if (!alphabet) {\n    setCharacters(ORIGINAL);\n  }\n\n  var sourceArray = alphabet.split('');\n  var targetArray = [];\n  var r = randomFromSeed.nextValue();\n  var characterIndex;\n\n  while (sourceArray.length > 0) {\n    r = randomFromSeed.nextValue();\n    characterIndex = Math.floor(r * sourceArray.length);\n    targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n  }\n\n  return targetArray.join('');\n}\n\nfunction getShuffled() {\n  if (shuffled) {\n    return shuffled;\n  }\n\n  shuffled = shuffle();\n  return shuffled;\n}\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\n\n\nfunction lookup(index) {\n  var alphabetShuffled = getShuffled();\n  return alphabetShuffled[index];\n}\n\nfunction get() {\n  return alphabet || ORIGINAL;\n}\n\nmodule.exports = {\n  get: get,\n  characters: characters,\n  seed: setSeed,\n  lookup: lookup,\n  shuffled: getShuffled\n};","'use strict';\n\nmodule.exports = require('./lib/index');","'use strict';\n\nvar alphabet = require('./alphabet');\n\nvar build = require('./build');\n\nvar isValid = require('./is-valid'); // if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\n\n\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\n\nfunction seed(seedValue) {\n  alphabet.seed(seedValue);\n  return module.exports;\n}\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\n\n\nfunction worker(workerId) {\n  clusterWorkerId = workerId;\n  return module.exports;\n}\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\n\n\nfunction characters(newCharacters) {\n  if (newCharacters !== undefined) {\n    alphabet.characters(newCharacters);\n  }\n\n  return alphabet.shuffled();\n}\n/**\n * Generate unique id\n * Returns string id\n */\n\n\nfunction generate() {\n  return build(clusterWorkerId);\n} // Export all other functions as properties of the generate function\n\n\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.isValid = isValid;","'use strict'; // Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\n\nfunction getNextValue() {\n  seed = (seed * 9301 + 49297) % 233280;\n  return seed / 233280.0;\n}\n\nfunction setSeed(_seed_) {\n  seed = _seed_;\n}\n\nmodule.exports = {\n  nextValue: getNextValue,\n  seed: setSeed\n};","'use strict';\n\nvar generate = require('./generate');\n\nvar alphabet = require('./alphabet'); // Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\n\n\nvar REDUCE_TIME = 1567752802062; // don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\n\nvar version = 7; // Counter is used when shortid is called multiple times in one second.\n\nvar counter; // Remember the last time shortid was called in case counter is needed.\n\nvar previousSeconds;\n/**\n * Generate unique id\n * Returns string id\n */\n\nfunction build(clusterWorkerId) {\n  var str = '';\n  var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n  if (seconds === previousSeconds) {\n    counter++;\n  } else {\n    counter = 0;\n    previousSeconds = seconds;\n  }\n\n  str = str + generate(version);\n  str = str + generate(clusterWorkerId);\n\n  if (counter > 0) {\n    str = str + generate(counter);\n  }\n\n  str = str + generate(seconds);\n  return str;\n}\n\nmodule.exports = build;","'use strict';\n\nvar alphabet = require('./alphabet');\n\nvar random = require('./random/random-byte');\n\nvar format = require('nanoid/format');\n\nfunction generate(number) {\n  var loopCounter = 0;\n  var done;\n  var str = '';\n\n  while (!done) {\n    str = str + format(random, alphabet.get(), 1);\n    done = number < Math.pow(16, loopCounter + 1);\n    loopCounter++;\n  }\n\n  return str;\n}\n\nmodule.exports = generate;","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nvar randomByte;\n\nif (!crypto || !crypto.getRandomValues) {\n  randomByte = function randomByte(size) {\n    var bytes = [];\n\n    for (var i = 0; i < size; i++) {\n      bytes.push(Math.floor(Math.random() * 256));\n    }\n\n    return bytes;\n  };\n} else {\n  randomByte = function randomByte(size) {\n    return crypto.getRandomValues(new Uint8Array(size));\n  };\n}\n\nmodule.exports = randomByte;","/**\n * Secure random string generator with custom alphabet.\n *\n * Alphabet must contain 256 symbols or less. Otherwise, the generator\n * will not be secure.\n *\n * @param {generator} random The random bytes generator.\n * @param {string} alphabet Symbols to be used in new random string.\n * @param {size} size The number of symbols in new random string.\n *\n * @return {string} Random string.\n *\n * @example\n * const format = require('nanoid/format')\n *\n * function random (size) {\n *   const result = []\n *   for (let i = 0; i < size; i++) {\n *     result.push(randomByte())\n *   }\n *   return result\n * }\n *\n * format(random, \"abcdef\", 5) //=> \"fbaef\"\n *\n * @name format\n * @function\n */\nmodule.exports = function (random, alphabet, size) {\n  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;\n  var step = Math.ceil(1.6 * mask * size / alphabet.length);\n  size = +size;\n  var id = '';\n\n  while (true) {\n    var bytes = random(step);\n\n    for (var i = 0; i < step; i++) {\n      var byte = bytes[i] & mask;\n\n      if (alphabet[byte]) {\n        id += alphabet[byte];\n        if (id.length === size) return id;\n      }\n    }\n  }\n};\n/**\n * @callback generator\n * @param {number} bytes The number of bytes to generate.\n * @return {number[]} Random bytes.\n */","'use strict';\n\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n  if (!id || typeof id !== 'string' || id.length < 6) {\n    return false;\n  }\n\n  var nonAlphabetic = new RegExp('[^' + alphabet.get().replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&') + ']');\n  return !nonAlphabetic.test(id);\n}\n\nmodule.exports = isShortId;","'use strict';\n\nmodule.exports = 0;","// Component rendering-related items\nexport var COMPONENT_CLASSNAME = 'vds-input-card';\nexport var COMPONENT_WRAPPER_CLASSNAME = 'vds-cardnumber';\nexport var INDICATOR_CLASSNAME = 'vds-card-indicator';\nexport var INDICATOR_WRAPPER_CLASSNAME = 'vds-input-option';\nexport var LENGTH_AMEX = 17; // 15-digit card number plus 2 masked spaces\n\nexport var LENGTH_DEFAULT = 19; // 16-digit card number plus 3 masked spaces\n\nexport var FIVE_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/, /\\d/];\nexport var FOUR_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/];\nexport var SIX_DIGITS = [/\\d/, /\\d/, /\\d/, /\\d/, /\\d/, /\\d/];\nexport var AMEX_MASK = [].concat(FOUR_DIGITS, [' '], SIX_DIGITS, [' '], FIVE_DIGITS);\nexport var NON_AMEX_MASK = [].concat(FOUR_DIGITS, [' '], FOUR_DIGITS, [' '], FOUR_DIGITS, [' '], FOUR_DIGITS);\n/**\n * Card Brands\n *\n * All brands are used for when there is at least one digit entered by the user\n *\n */\n\nexport var AMEX = 'AMEX';\nexport var DISCOVER = 'DISCOVER';\nexport var ELECTRON = 'ELECTRON';\nexport var ELO = 'ELO';\nexport var INVALID = 'INVALID';\nexport var MASTERCARD = 'MASTERCARD';\nexport var UNKNOWN = 'UNKNOWN';\nexport var VISA = 'VISA'; // Card Validation Errors\n\nexport var EMPTY = 'EMPTY';\nexport var INVALID_BIN = 'INVALID_BIN';\nexport var INVALID_BIN_BRAND = 'INVALID_BIN_BRAND';\nexport var INVALID_GENERIC = 'INVALID_GENERIC';\nexport var NOT_SUPPORTED = 'NOT_SUPPORTED';\nexport var PARTIAL = 'PARTIAL'; // These errors are all triggered onChange except where noted\n\nexport var ERROR_MAP = {\n  empty: EMPTY,\n  // field is empty\n  invalid_bin: INVALID_BIN,\n  // first digit does not map to a known card brand\n  invalid_bin_brand: INVALID_BIN_BRAND,\n  // brand is recognized but bin range is not valid\n  invalid_generic: INVALID_GENERIC,\n  // card number is invalid for some other reason not specified\n  not_supported: NOT_SUPPORTED,\n  // brand is recognized but not supported by merchant / partner\n  partial: PARTIAL // partial value, triggered only onBlur\n\n};","import { AMEX, DISCOVER, ELO, MASTERCARD, VISA } from '../constants';\nexport var brands = [AMEX, DISCOVER, ELO, MASTERCARD, VISA];\n/**\n  * If the value's first digit does not map to one of these it will cause the\n  `possibleBrand` to be `INVALID` and the validator to return `invalid_bin`.\n  */\n\nexport var brandMatrix = {\n  '2': MASTERCARD,\n  '3': AMEX,\n  '4': VISA,\n  '5': MASTERCARD,\n  '6': DISCOVER\n};\n/**\n  * If the value's first digit maps to one of the `brandMatrix` brands but the rest of the\n  value, aka 'bin,' does not follow the below logic, it will cause the `possibleBrand` to be\n  one of the known brands in `brandMatrix` and the validator to return `invalid_bin_brand`.\n  */\n\nexport var binMatrix = {\n  AMEX: ['34', '37'],\n  DISCOVER: {\n    fourDigits: ['6011'],\n    ranges: {\n      4: {\n        max: 6229,\n        min: 6221\n      },\n      5: {\n        max: 62292,\n        min: 62212\n      },\n      6: {\n        max: 622925,\n        min: 622126\n      },\n      7: {\n        max: 6229259,\n        min: 6221260\n      },\n      8: {\n        max: 62292599,\n        min: 62212600\n      }\n    },\n    twoOrThreeDigits: ['60', '62', '65', '601', '622']\n  },\n  MASTERCARD: {\n    ranges: {\n      1: {\n        max: 2,\n        min: 2\n      },\n      2: {\n        max: 27,\n        min: 22\n      },\n      3: {\n        max: 272,\n        min: 222\n      },\n      4: {\n        max: 2720,\n        min: 2221\n      },\n      5: {\n        max: 27209,\n        min: 22210\n      },\n      6: {\n        max: 272099,\n        min: 222100\n      }\n    },\n    twoDigits: ['51', '52', '53', '54', '55']\n  },\n  VISA: ['4']\n};","import { brands } from './brandBinMatrix';\nimport { UNKNOWN } from '../constants';\n/**\n * @description check user-entered cardBrand against merchant- and partner-supported brands.\n * Call function only if shouldValidateAcceptedCards prop is true in your component.\n *\n * @param {string} cardBrand\n * @param {array} acceptedBrands defaults to all brands\n * @return {bool}\n */\n\nexport default (function (cardBrand) {\n  var acceptedBrands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : brands;\n  var acceptedBrandsLength = acceptedBrands.length;\n  var isAccepted = false;\n\n  if (cardBrand === UNKNOWN) {\n    return true;\n  }\n\n  for (var brand = 0; brand < acceptedBrandsLength; brand++) {\n    if (acceptedBrands[brand] === cardBrand) {\n      isAccepted = true;\n      break;\n    }\n  }\n\n  return isAccepted;\n});","export default (function (value) {\n  return value.toString().replace(/\\s+/g, '');\n});","/* eslint-disable spellcheck/spell-checker */\nimport { brandMatrix } from './brandBinMatrix';\nimport { ELO, INVALID, UNKNOWN } from '../constants';\n/**\n * @description Checks if the entered card number is for an Elo bin\n *\n * @param {string} cardNum\n * @param {string} cardBrand\n * @param {array} eloBins\n * @returns {string}\n */\n\nexport var eloOrOther = function eloOrOther(cardNum, cardBrand, eloBins) {\n  if (eloBins && eloBins.length > 0) {\n    for (var i = 0; i < eloBins.length; i++) {\n      if (cardNum.indexOf(eloBins[i].toString()) === 0) {\n        // cardNum starts with an Elo prefix and is definitely Elo\n        return ELO;\n      } else if (eloBins[i].toString().indexOf(cardNum) === 0) {\n        // cardNum is part of an Elo prefix but not confirmed Elo\n        return UNKNOWN;\n      }\n    }\n  }\n\n  return cardBrand;\n};\n/**\n * @description Checks what is the cardBrand based on provided value\n *\n * @param {string} cardNum\n * @param {array} eloBins\n * @returns {string}\n */\n\nvar getPossibleBrand = function getPossibleBrand(cardNum, eloBins) {\n  var possibleBrand = UNKNOWN;\n\n  if (!cardNum.length) {\n    return possibleBrand;\n  }\n\n  var firstDigit = cardNum[0];\n  possibleBrand = brandMatrix[firstDigit] || INVALID;\n  possibleBrand = possibleBrand === INVALID ? INVALID : eloOrOther(cardNum, possibleBrand, eloBins);\n  return possibleBrand;\n};\n\nexport default getPossibleBrand;","/* eslint-disable spellcheck/spell-checker */\nimport { binMatrix } from './brandBinMatrix';\nimport getRawValue from './getRawValue';\nimport getPossibleBrand from './possibleBrand.js';\nimport { AMEX, DISCOVER, ELO, INVALID, MASTERCARD, UNKNOWN, VISA } from '../constants';\n/**\n * @description execute for loop for common use cases to determine if passed digits map to a valid bin\n * Note: This method is designed to be called only when the card brand is known && when digits.length is > 1.\n It is not designed to be called directly by the card number component, but, rather, is called only as a\n result of calling `__getIsValidBin` method, also located in this file.\n Putting all the card bin/brand validation logic together it's not possible for this method to be called unless\n digits.length > 1 && there are specific possibleBins.\n *\n * @param {string} digits\n * @param {array} possibleBins\n * @returns {bool}\n */\n\nvar __checkTwoOrThreeDigits = function __checkTwoOrThreeDigits(digits, possibleBins) {\n  var possibleBinsLength = possibleBins.length;\n  var isValidBin = false;\n\n  for (var bin = 0; bin < possibleBinsLength; bin++) {\n    if (digits === possibleBins[bin]) {\n      isValidBin = true;\n      break;\n    }\n  }\n\n  return isValidBin;\n};\n/**\n * @description check if provided card number is valid for mastercard\n * currently used only for 2-series mastercards\n *\n * @param {string} cardNum\n * @returns {bool}\n */\n\n\nvar __isValidMasterCard = function __isValidMasterCard(cardNum) {\n  var cardNumsToValidate = cardNum.length < 7 ? cardNum : cardNum.substr(0, 6);\n  var validationNumsLength = cardNumsToValidate.length;\n  var validationRange = binMatrix[MASTERCARD]['ranges'][validationNumsLength]; // eslint-disable-line dot-notation\n\n  return validationRange.min <= Number(cardNumsToValidate) && Number(cardNumsToValidate) <= validationRange.max;\n};\n/**\n * @description check if provided card number is valid for discover\n * currently used only for discover cards beginning with 622*\n *\n * @param {string} cardNum\n * @returns {bool}\n */\n\n\nvar __isValidDiscoverCard = function __isValidDiscoverCard(cardNum) {\n  var digitsToCheck;\n  var isValidBin;\n  var possibleBins;\n  var isFewerThanFourDigits = cardNum.length < 4;\n\n  if (cardNum.length === 1) {\n    isValidBin = true;\n  } else if (cardNum.substr(0, 2) === '65') {\n    isValidBin = true;\n  } else if (isFewerThanFourDigits) {\n    digitsToCheck = cardNum.substr(0, 3);\n    possibleBins = binMatrix[DISCOVER]['twoOrThreeDigits']; // eslint-disable-line dot-notation\n\n    isValidBin = __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n  } else if (cardNum.substr(0, 4) === '6011') {\n    isValidBin = true;\n  } else {\n    var cardNumsToValidate = cardNum.substr(0, 8);\n    var validationNumsLength = cardNumsToValidate.length;\n    var validationRange = binMatrix[DISCOVER]['ranges'][validationNumsLength]; // eslint-disable-line dot-notation\n\n    isValidBin = validationRange.min <= Number(cardNumsToValidate) && Number(cardNumsToValidate) <= validationRange.max;\n  }\n\n  return isValidBin;\n};\n/**\n * @description checks bin range of entered card number\n *\n * There is a separate onBlur check for if the entered card number is a complete card number for that brand.\n *\n * The check for whether a card might be elo will return 'elo', 'unknown', or a cardBrand.\n * All cards starting with '4' are valid whether 'elo' or 'visa'.\n * All 'unknown' cards are valid.\n *\n * 'amex' cards currently have only two bin ranges so the for loop is good enough for this brand\n * 'mastercard' 5-series cards have only five bin ranges so the for loop is good enough for this brand\n *\n *\n * @param {string} possibleBrand\n * @param {string} cardNum\n * @returns {bool}\n */\n\n\nvar __getIsValidBin = function __getIsValidBin(possibleBrand, cardNum) {\n  var cardNumLengthOne = cardNum.length === 1;\n  var isValidBin = false;\n  var possibleBins;\n  var firstDigit;\n  var digitsToCheck;\n\n  switch (possibleBrand) {\n    case ELO:\n    case UNKNOWN:\n    case VISA:\n      isValidBin = true;\n      break;\n\n    case AMEX:\n      var cardNumLength = cardNum.length;\n      digitsToCheck = cardNum.substr(0, 2);\n      possibleBins = binMatrix[possibleBrand];\n      isValidBin = cardNumLength === 1 ? true : __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n      break;\n\n    case MASTERCARD:\n      firstDigit = cardNum[0];\n      digitsToCheck = cardNum.substr(0, 2);\n      var firstDigitIsFive = firstDigit === '5';\n\n      if (cardNumLengthOne) {\n        isValidBin = true;\n      } else if (firstDigitIsFive) {\n        possibleBins = binMatrix[possibleBrand]['twoDigits']; // eslint-disable-line dot-notation\n\n        isValidBin = __checkTwoOrThreeDigits(digitsToCheck, possibleBins);\n      } else {\n        isValidBin = __isValidMasterCard(cardNum);\n      }\n\n      break;\n\n    case DISCOVER:\n      isValidBin = __isValidDiscoverCard(cardNum);\n      break;\n\n    default:\n  }\n\n  return isValidBin;\n};\n/**\n * @description determines if the entered card number is for a valid cardBrand in a valid bin range\n *\n * @param {string} cardNum\n * @param {array} eloBins\n * @returns {bool}\n */\n\n\nexport default (function (cardNum, eloBins) {\n  cardNum = getRawValue(cardNum);\n  var possibleBrand = getPossibleBrand(cardNum, eloBins);\n  var isInvalid = possibleBrand === INVALID || !__getIsValidBin(possibleBrand, cardNum);\n  return !isInvalid;\n});","import { ELECTRON, VISA } from '../constants';\n/**\n * @param {array} brands\n * @returns {array}\n */\n\nexport default (function (brands) {\n  var brandsLen = brands.length;\n  var unfilteredArr = [];\n\n  for (var brand = 0; brand < brandsLen; brand++) {\n    if (brands[brand] === ELECTRON) {\n      unfilteredArr.push(VISA);\n    } else {\n      unfilteredArr.push(brands[brand]);\n    }\n  } // remove possible duplicates and return the result\n\n\n  return unfilteredArr.filter(function (v, i, a) {\n    return a.indexOf(v) === i;\n  });\n});","import { brands } from './brandBinMatrix';\nexport default (function (brand) {\n  var brandIsKnown = brands.indexOf(brand) > -1;\n  var prefix = brandIsKnown ? '--' : '';\n  var brandName = brandIsKnown ? brand.toLowerCase() : '';\n  return \"\".concat(prefix).concat(brandName);\n});","import getRawValue from './getRawValue';\nvar PRODUCT_ARRAY = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]];\n/**\n * @param {string} value\n * @return {bool}\n */\n\nvar ccMod10Check = function ccMod10Check(value) {\n  if (value) {\n    value = getRawValue(value); // numbers only\n\n    var l = value.length;\n    var multiple = 0;\n    var sum = 0;\n\n    while (l--) {\n      sum += PRODUCT_ARRAY[multiple][parseInt(value.charAt(l), 10)];\n      multiple ^= 1;\n    }\n\n    return sum > 0 && sum % 10 === 0;\n  }\n\n  return true;\n};\n/**\n * @param {string} value\n * @return {bool}\n */\n\n\nvar ccMod11Check = function ccMod11Check(value) {\n  if (value) {\n    value = getRawValue(value); // numbers only\n\n    var len = value.length; // usually 16\n\n    var digit = value[len - 1]; // tester digit\n\n    var testDigits = value.substr(0, len - 1); // 15 digits (drops the last value)\n\n    var i;\n    var myCheck;\n    var total = 0;\n    var temp;\n\n    for (i = len - 1; i > 0;) {\n      temp = Number(testDigits[--i]);\n\n      if (i % 2 == 0) {\n        temp *= 2;\n      }\n\n      if (temp > 9) {\n        temp -= 9;\n      }\n\n      total += temp;\n    }\n\n    myCheck = (10 - total % 10) % 10;\n    myCheck = (myCheck + 1) % 10;\n\n    if (myCheck == digit) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return true;\n};\n/**\n * @param {string} value\n * @param {bool} checkMod11\n * @return {bool}\n */\n\n\nexport default (function (value, checkMod11) {\n  var mod10 = true;\n  var mod11 = checkMod11;\n  var isMod10 = ccMod10Check(value);\n  var isMod11 = false;\n\n  if (mod11) {\n    isMod11 = ccMod11Check(value);\n  }\n\n  var passesCheck = mod10 && mod11 ? // either\n  isMod10 || isMod11 : // specific\n  mod10 ? isMod10 : isMod11;\n  return passesCheck;\n});","import acceptedBrandsCheck from './acceptedBrandsCheck';\nimport binCheck from './binCheck';\nimport { brands } from './brandBinMatrix';\nimport getRawValue from './getRawValue';\nimport checkMod from './modCheck';\nimport getPossibleBrand from './possibleBrand';\nimport { AMEX, LENGTH_AMEX, LENGTH_DEFAULT } from '../constants';\nexport default (function (maskedCardNumber) {\n  var conditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _conditions$cardBins = conditions.cardBins,\n      cardBins = _conditions$cardBins === void 0 ? null : _conditions$cardBins,\n      _conditions$checkMods = conditions.checkMods,\n      checkMods = _conditions$checkMods === void 0 ? false : _conditions$checkMods,\n      _conditions$partnerAc = conditions.partnerAcceptedBrands,\n      partnerAcceptedBrands = _conditions$partnerAc === void 0 ? brands : _conditions$partnerAc,\n      _conditions$shouldChe = conditions.shouldCheckAcceptedBrands,\n      shouldCheckAcceptedBrands = _conditions$shouldChe === void 0 ? false : _conditions$shouldChe,\n      _conditions$validateM = conditions.validateMod11,\n      validateMod11 = _conditions$validateM === void 0 ? false : _conditions$validateM;\n  var rawValue = getRawValue(maskedCardNumber);\n  var possibleBrand = getPossibleBrand(rawValue, cardBins);\n  var maxLength = possibleBrand === AMEX ? LENGTH_AMEX : LENGTH_DEFAULT;\n  var passesMod = checkMods ? maskedCardNumber.length === maxLength && checkMod(maskedCardNumber, validateMod11) : true;\n  var isSupportedBrand = shouldCheckAcceptedBrands ? acceptedBrandsCheck(possibleBrand, partnerAcceptedBrands) : true;\n  var isValidBin = binCheck(rawValue, cardBins);\n  var isValid = shouldCheckAcceptedBrands ? isSupportedBrand && isValidBin : isValidBin;\n  return {\n    brand: possibleBrand,\n    isSupported: isSupportedBrand,\n    isValid: isValid,\n    passesMod: passesMod,\n    value: maskedCardNumber\n  };\n});","import { AMEX, AMEX_MASK, NON_AMEX_MASK } from '../constants';\nexport default (function (brand) {\n  return brand === AMEX ? AMEX_MASK : NON_AMEX_MASK;\n});","import { AMEX, ERROR_MAP, INVALID, LENGTH_AMEX, LENGTH_DEFAULT } from '../constants';\nimport checkMod from './modCheck';\nexport var validator = function validator(isBlur) {\n  var conditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var brand = conditions.brand,\n      _conditions$checkMods = conditions.checkMods,\n      checkMods = _conditions$checkMods === void 0 ? false : _conditions$checkMods,\n      _conditions$checkMod = conditions.checkMod11,\n      checkMod11 = _conditions$checkMod === void 0 ? false : _conditions$checkMod,\n      _conditions$isSupport = conditions.isSupported,\n      isSupported = _conditions$isSupport === void 0 ? true : _conditions$isSupport,\n      _conditions$isValid = conditions.isValid,\n      isValid = _conditions$isValid === void 0 ? true : _conditions$isValid,\n      value = conditions.value;\n  var maxLength = brand === AMEX ? LENGTH_AMEX : LENGTH_DEFAULT;\n  var isPartialValue = value.length < maxLength;\n  var error;\n  /**\n   * `!value` means the field is empty (`ERROR_MAP.empty`)\n   * `!isSupported && brand !== INVALID` means entered value maps to a known card brand\n   but that brand is not supported by the partner or merchant. (`ERROR_MAP.not_supported`)\n   * `brand === INVALID` means the entered value does not map to a known card brand. (`ERROR_MAP.invalid_bin`)\n   * `!isValid` means the value maps to a known card brand but the value's bin is not valid for that card brand.\n   (`ERROR_MAP.invalid_bin_brand`)\n   * `!isPartialValue && checkMods && !checkMod(value, checkMod11)` is for when there is a full and complete\n   value for the card brand but the value does not pass mod checks, when mod checks are enabled. (`ERROR_MAP.invalid_generic`)\n   * `isPartialValue && isBlur` means that the entered value is a partial value for that card brand. (`ERROR_MAP.partial`)\n   */\n\n  if (!value) {\n    error = ERROR_MAP.empty;\n  } else if (!isSupported && brand !== INVALID) {\n    error = ERROR_MAP.not_supported;\n  } else if (brand === INVALID) {\n    error = ERROR_MAP.invalid_bin;\n  } else if (!isValid) {\n    error = ERROR_MAP.invalid_bin_brand;\n  } else if (!isPartialValue && checkMods && !checkMod(value, checkMod11)) {\n    error = ERROR_MAP.invalid_generic;\n  } else if (isPartialValue && isBlur) {\n    error = ERROR_MAP.partial;\n  }\n\n  return error;\n};","import * as constants from './constants';\nimport * as utilities from './utilities';\nexport { constants, utilities };","/* eslint-disable no-labels */\nimport { isArray, NO_MASK_ERROR, NO_PLACEHOLDER_CHAR_IN_MASK } from './index';\nvar emptyArray = [];\nvar emptyString = '';\n/**\n * This function returns an object with a property conformedValue (string).\n * It will also indicate if any characters were rejected\n *\n * @param {String} rawValue\n * @param {Array} mask\n * @param {Object} config\n * @return {{conformedValue: string, meta: {someCharsRejected: boolean}}}\n */\n\nexport default function conformToMask() {\n  var rawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyString;\n  var mask = arguments.length > 1 ? arguments[1] : undefined;\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // These configurations tell us how to conform the mask\n\n  var _config$currentCaretP = config.currentCaretPosition,\n      currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n      _config$guide = config.guide,\n      guide = _config$guide === void 0 ? false : _config$guide,\n      _config$placeholder = config.placeholder,\n      placeholder = _config$placeholder === void 0 ? emptyString : _config$placeholder,\n      _config$placeholderCh = config.placeholderChars,\n      placeholderChars = _config$placeholderCh === void 0 ? emptyArray : _config$placeholderCh,\n      _config$previousConfo = config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? emptyString : _config$previousConfo;\n\n  if (!isArray(mask)) {\n    throw new Error(NO_MASK_ERROR);\n  }\n\n  if (mask.filter(function (char) {\n    return placeholderChars.includes(char);\n  }).length > 0) {\n    throw new Error(NO_PLACEHOLDER_CHAR_IN_MASK);\n  } // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined;\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // Convert rawValue to an array and track whether a character is new\n\n  var rawValueArr = rawValue.split(emptyString); // Remove any placeholder characters from rawValueArr\n\n  for (var i = rawValueLength - 1; i >= 0; i--) {\n    var char = rawValueArr[i];\n\n    if (!placeholderChars.includes(char)) {\n      var shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = emptyString;\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i = 0; _i < placeholderLength; _i++) {\n    var charInPlaceholder = placeholder[_i]; // We see one. Let's find out what we can put in it.\n\n    if (placeholderChars.includes(charInPlaceholder)) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          var rawValueChar = rawValueArr.shift();\n\n          if (rawValueChar === charInPlaceholder && suppressGuide !== true) {\n            conformedValue += charInPlaceholder; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i].test(rawValueChar)) {\n            conformedValue += rawValueChar; // Since we've mapped this placeholder position. We move on to the next one.\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      }\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i, placeholderLength);\n      }\n\n      break;\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  }\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i2 = 0; _i2 < conformedValue.length; _i2++) {\n      if (placeholderChars.includes(placeholder[_i2])) {\n        indexOfLastFilledPlaceholderChar = _i2;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar === null) {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString;\n    } else {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}","/* eslint-disable no-lonely-if */\nvar emptyArray = [];\nvar emptyString = '';\n/**\n * Will return an integer representing the index of where the caret should be moved to next\n *\n * @param {String} conformedValue\n * @param {Number} currentCaretPosition\n * @param {Array} nonRegexChars\n * @param {String} placeholder\n * @param {Array} placeholderChars\n * @param {String} previousConformedValue\n * @param {String} previousPlaceholder\n * @param {String} rawValue\n * @return {Number}\n */\n\nexport default function adjustCaretPosition(_ref) {\n  var _ref$conformedValue = _ref.conformedValue,\n      conformedValue = _ref$conformedValue === void 0 ? emptyString : _ref$conformedValue,\n      _ref$currentCaretPosi = _ref.currentCaretPosition,\n      currentCaretPosition = _ref$currentCaretPosi === void 0 ? 0 : _ref$currentCaretPosi,\n      _ref$nonRegexChars = _ref.nonRegexChars,\n      nonRegexChars = _ref$nonRegexChars === void 0 ? emptyArray : _ref$nonRegexChars,\n      _ref$placeholder = _ref.placeholder,\n      placeholder = _ref$placeholder === void 0 ? emptyString : _ref$placeholder,\n      _ref$placeholderChars = _ref.placeholderChars,\n      placeholderChars = _ref$placeholderChars === void 0 ? emptyArray : _ref$placeholderChars,\n      _ref$previousConforme = _ref.previousConformedValue,\n      previousConformedValue = _ref$previousConforme === void 0 ? emptyString : _ref$previousConforme,\n      _ref$previousPlacehol = _ref.previousPlaceholder,\n      previousPlaceholder = _ref$previousPlacehol === void 0 ? emptyString : _ref$previousPlacehol,\n      _ref$rawValue = _ref.rawValue,\n      rawValue = _ref$rawValue === void 0 ? emptyString : _ref$rawValue;\n\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  }\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var conformedValueLength = conformedValue.length;\n  var editLength = rawValueLength - previousConformedValueLength; // If the edit length is positive, that means the user is adding characters, not deleting.\n\n  var isAddition = editLength > 0; // This is the first raw value the user entered that needs to be conformed to mask\n\n  var isFirstRawValue = previousConformedValueLength === 0; // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace. Such cases can also happen when the\n  // user presses the backspace while holding down the ALT key.\n\n  var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  } // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n\n\n  var possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n  var startingSearchIndex = 0;\n  var trackRightCharacter;\n  var targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    var normalizedConformedValue = conformedValue.toLowerCase();\n    var normalizedRawValue = rawValue.toLowerCase(); // Then we take all characters that come before where the caret currently is.\n\n    var leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString); // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n\n    var intersection = leftHalfChars.filter(function (char) {\n      return normalizedConformedValue.indexOf(char) !== -1;\n    }); // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n\n    targetChar = intersection[intersection.length - 1]; // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n\n    var previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return !placeholderChars.includes(char);\n    }).length; // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n\n    var leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return !placeholderChars.includes(char);\n    }).length; // Has the number of mask characters up to the caret changed?\n\n    var maskLengthChanged = leftMaskChars !== previousLeftMaskChars; // Detect if `targetChar` is a mask character and has moved to the left\n\n    var targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && !placeholderChars.includes(previousPlaceholder[intersection.length - 1]) && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]; // If deleting and the `targetChar` `is a mask character and `maskLengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n\n    if (!isAddition && (maskLengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    } // We need to know how many times it occurs in the intersection\n\n\n    var countTargetCharInIntersection = intersection.filter(function (char) {\n      return char === targetChar;\n    }).length; // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n\n    var countTargetCharInPlaceholder = placeholder.split(emptyString).filter(function (char, index) {\n      return !nonRegexChars.includes(char) && char === targetChar && rawValue[index] !== char;\n    }).length; // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking for is:\n\n    var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + ( // The character to the right of the caret isn't included in `intersection`\n    // so add one if we are tracking the character to the right\n    trackRightCharacter ? 1 : 0); // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n\n    var numberOfEncounteredMatches = 0;\n\n    for (var i = 0; i < conformedValueLength; i++) {\n      var conformedValueChar = normalizedConformedValue[i];\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  } // In case of addition, we fast forward.\n\n\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    var lastPlaceholderChar = startingSearchIndex;\n\n    for (var _i = startingSearchIndex; _i <= placeholderLength; _i++) {\n      if (placeholderChars.includes(placeholder[_i])) {\n        lastPlaceholderChar = _i;\n      }\n\n      if (placeholderChars.includes(placeholder[_i]) || _i === placeholderLength) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (var _i2 = startingSearchIndex - 1; _i2 >= 0; _i2--) {\n        if (conformedValue[_i2] === targetChar || _i2 === 0) {\n          return _i2;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n      for (var _i3 = startingSearchIndex; _i3 >= 0; _i3--) {\n        if (placeholderChars.includes(placeholder[_i3 - 1]) || _i3 === 0) {\n          return _i3;\n        }\n      }\n    }\n  }\n\n  return -1;\n}","import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport { adjustCaretPosition, conformToMask, cleanMask, safeSetSelection, isHTMLInputElement, isNil, NO_INPUT_ERROR } from './index';\n/**\n * This function takes a configuration and returns an object with an update method.\n * The update method is used to conform the raw value to the mask you provide in the config\n *\n * @param {Object} config\n * @return {{state: Object, update: Function}}\n */\n\nexport default function createTextMaskInputElement() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    update: function update(rawValue) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config,\n          _ref$guide = _ref.guide,\n          guide = _ref$guide === void 0 ? false : _ref$guide,\n          inputElement = _ref.inputElement,\n          mask = _ref.mask,\n          _ref$placeholderChar = _ref.placeholderChar,\n          placeholderChar = _ref$placeholderChar === void 0 ? 'X' : _ref$placeholderChar,\n          _ref$upperCaseValue = _ref.upperCaseValue,\n          upperCaseValue = _ref$upperCaseValue === void 0 ? false : _ref$upperCaseValue;\n\n      if (!isHTMLInputElement(inputElement)) {\n        throw new Error(NO_INPUT_ERROR);\n      }\n\n      var currentCaretPosition = inputElement.selectionEnd,\n          inputValue = inputElement.value;\n\n      if (isNil(rawValue)) {\n        rawValue = inputValue;\n      } else {\n        rawValue = rawValue.toString();\n      }\n\n      var _cleanMask = cleanMask(mask, placeholderChar),\n          cleanedMask = _cleanMask.mask,\n          placeholder = _cleanMask.placeholder,\n          nonRegexChars = _cleanMask.nonRegexChars,\n          placeholderChars = _cleanMask.placeholderChars;\n\n      if (rawValue === state.previousConformedValue && placeholder === state.previousPlaceholder) {\n        return _objectSpread({}, state, {\n          adjustedCaretPosition: currentCaretPosition,\n          conformedValue: rawValue\n        });\n      }\n\n      var _conformToMask = conformToMask(rawValue, cleanedMask, {\n        currentCaretPosition: currentCaretPosition,\n        guide: guide,\n        placeholder: placeholder,\n        placeholderChars: placeholderChars,\n        previousConformedValue: state.previousConformedValue\n      }),\n          conformedValue = _conformToMask.conformedValue;\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        conformedValue: conformedValue,\n        currentCaretPosition: currentCaretPosition,\n        nonRegexChars: nonRegexChars,\n        placeholder: placeholder,\n        placeholderChars: placeholderChars,\n        previousConformedValue: state.previousConformedValue,\n        previousPlaceholder: state.previousPlaceholder,\n        rawValue: rawValue\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = conformedValue === placeholder && adjustedCaretPosition === 0;\n      var inputElementValue = inputValueShouldBeEmpty ? '' : upperCaseValue ? conformedValue.toUpperCase() : conformedValue;\n      state.previousConformedValue = inputElementValue;\n      state.previousPlaceholder = placeholder;\n      inputElement.value = inputElementValue;\n      safeSetSelection(inputElement, adjustedCaretPosition);\n      return _objectSpread({}, state, {\n        adjustedCaretPosition: adjustedCaretPosition,\n        conformedValue: inputElementValue\n      });\n    }\n  };\n}","import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { NO_MASK_ERROR } from './index';\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nvar defer = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame;\n/**\n * Set cursor position on an input element\n * @param {HTMLElement} element\n * @param {Number} selectionPosition\n */\n\nexport function safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(function () {\n        return element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n      }, 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n    }\n  }\n}\n/**\n * Tells you whether a value is a string\n * @param {String} value\n * @return {Boolean}\n */\n\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n/**\n * Tells you whether a value is a array\n * @param {String} value\n * @return {Boolean}\n */\n\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\n/**\n * Tells you whether a value is nil\n * @param {String} value\n * @return {Boolean}\n */\n\nexport function isNil(value) {\n  return typeof value === 'undefined' || value === null;\n}\n/**\n * Tells you whether an element is an input type\n * @param {HTMLElement} element\n * @return {Boolean}\n */\n\nexport function isHTMLInputElement(element) {\n  return (element instanceof Element || element instanceof HTMLDocument) && element.nodeType === 1 && element.tagName.toLowerCase() === 'input';\n}\n/**\n * Tells you whether a value is a string and has a length > 0\n * @param {String} value\n * @return {Boolean}\n */\n\nexport function validString(value) {\n  return isString(value) && value.length > 0;\n}\n/**\n * Returns the display name of a component\n * @param {Component} WrappedComponent\n * @return {string | * | string}\n */\n\nexport function getComponentDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n/**\n * Returns an object containing all the info needed for Text-Mask library\n * @param {Array} mask\n * @param {String} placeholderChar\n * @return {{mask: [], nonRegexChars: [], placeholder: string, placeholderChars: []}}\n */\n\nexport function cleanMask(mask) {\n  var placeholderChar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'X';\n\n  if (!isArray(mask)) {\n    throw new Error(NO_MASK_ERROR);\n  }\n\n  var cleanedMask = mask.reduce(function (maskObj, char) {\n    var mask = maskObj.mask,\n        placeholderChars = maskObj.placeholderChars,\n        placeholder = maskObj.placeholder;\n    var maskChar = char && char.mask instanceof RegExp ? char.mask : char;\n    var placeChar = char && typeof char.placeholder === 'string' ? char.placeholder.charAt(0) : placeholderChar;\n    mask.push(typeof maskChar === 'string' ? maskChar.charAt(0) : maskChar);\n    placeholder.push(char instanceof RegExp || char.mask instanceof RegExp ? placeChar : char.toString().charAt(0));\n\n    if (!placeholderChars.includes(placeChar)) {\n      placeholderChars.push(placeChar);\n    }\n\n    return maskObj;\n  }, {\n    mask: [],\n    placeholder: [],\n    placeholderChars: []\n  }); // Filter out empty string\n\n  var cleanMask = cleanedMask.mask.filter(Boolean); // Create placeholder string representation\n\n  var placeholderStr = cleanedMask.placeholder.join(''); // Remove any duplicates from placeholder array and filter out empty string\n\n  var nonRegexChars = _toConsumableArray(new Set(cleanedMask.placeholder.filter(Boolean))); // Only use placeholder chars present in nonRegexChars array\n\n\n  var placeholderChars = cleanedMask.placeholderChars.filter(function (char) {\n    return nonRegexChars.includes(char);\n  }); // If our `placeholderChars` array is empty, default to using `placeholderChar`\n\n  if (placeholderChars.length === 0) {\n    placeholderChars = [placeholderChar];\n  }\n\n  return {\n    mask: cleanMask,\n    nonRegexChars: nonRegexChars,\n    placeholder: placeholderStr,\n    placeholderChars: placeholderChars\n  };\n}","export var NO_MASK_ERROR = \"An array containing a valid mask is required. Please refer to LINK_WIKI for more information\";\nexport var NO_INPUT_ERROR = \"An input element is required to enable Masking. Please refer to LINK_WIKI for more information\";\nexport var NO_PLACEHOLDER_CHAR_IN_MASK = 'A placeholder character must not be used as part of the mask. ' + 'Please specify a character that is not present in your mask as your placeholder character.';","export { default as conformToMask } from './conformToMask';\nexport { default as adjustCaretPosition } from './adjustCaretPosition';\nexport { default as createTextMaskInputElement } from './createTextMaskInputElement';\nexport { cleanMask, safeSetSelection, isString, isArray, isNil, isHTMLInputElement, validString, getComponentDisplayName } from './utilities';\nexport { NO_INPUT_ERROR, NO_MASK_ERROR, NO_PLACEHOLDER_CHAR_IN_MASK } from './constants';"],"sourceRoot":""}